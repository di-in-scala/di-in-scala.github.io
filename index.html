<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    Dependency Injection in Scala using MacWire &middot; DI in Scala: guide
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
  	<a href="https://github.com/di-in-scala/di-in-scala.github.io-sources"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/365986a132ccd6a44c23a9169022c0b5c890c387/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png"></a>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>DI in Scala: guide</h1>
      <p class="lead">Dependency Injection in Scala using MacWire</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
        <a href="/">Home</a>
      </li>

      <li class="sidebar-nav-item"><a href="https://github.com/adamw/macwire">MacWire on GitHub</a></li>
      <li class="sidebar-nav-item"><a href="http://www.warski.org">Adam Warski's blog</a></li>
      <li class="sidebar-nav-item">
        <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://di-in-scala.github.io/" data-text="Guide to Dependency Injection in #Scala" data-via="adamwarski">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
      </li>
    </ul>

    <p>
      &copy; 2017 by
      <a href="http://twitter.com/adamwarski">Adam Warski</a>.
    </p>
  </div>
</div>


    <div class="content container">
      <p><a name="top"></a></p>

<h1>Table of contents</h1>

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#manual">Manual Dependency Injection</a></li>
<li><a href="#macwire">Using MacWire for wiring</a></li>
<li><a href="#simplescopes">Simple scoping</a></li>
<li><a href="#modules">Modularising object graph creation</a></li>
<li><a href="#multiple">Multiple implementations</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#interceptors">Interceptors</a></li>
<li><a href="#advscopes">Advanced scoping</a></li>
<li><a href="#factories">Factories</a></li>
<li><a href="#dynamic">Accessing the object graph dynamically</a></li>
<li><a href="#multipleinst">Multiple instances</a></li>
<li><a href="#akka">DI in Akka</a></li>
<li><a href="#comments">Comments</a></li>
</ul>

<p><a name="introduction"></a></p>

<p><h1>Introduction</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<p><a href="http://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection (DI)</a> is a popular pattern which encourages loose coupling between a services’ clients and service implementations.</p>

<p>This guide describes how to do Dependency Injection using the Scala language constructs as much as possible, while remaining practical, with the help of the <a href="https://github.com/adamw/macwire">MacWire</a> library where necessary. </p>

<p>Dependency Injection is a <em>simple</em> concept, and it can be implemented using relatively few <em>simple</em> constructs. We should avoid over-complicating and over-using containers or frameworks, without thoroughly analysing the costs.</p>

<p class="message">
  This guide is <a href="https://github.com/di-in-scala/di-in-scala.github.io-sources">available on GitHub</a>, so if you think something is missing, not clear enough, or can be done better, don't hesitate and send a pull request!
</p>

<h2>What is Dependency Injection?</h2>

<p>DI is all about decoupling client and service code (the client may happen to be another service). Services need to expose information on what dependencies they need. Instead of creating dependent service implementations inside the service itself, <em>references</em> to dependent services are &quot;injected&quot;. This makes the code easier to understand, more testable and more reusable.</p>

<p>The means of injecting the dependencies vary from approach to approach, but the one we will be using here is passing dependencies through constructor parameters. Other possibilities include setter/field injection, or using a service locator. Hence, the essence of DI can be summarised as <em>using constructor parameters</em>.</p>

<p>A very important aspect of DI is Inversion of Control. The service implementations have to be created &quot;outside&quot; the services, e.g. by a container or some external wiring code. Using <code>new</code> directly to create a dependency is not allowed inside a service.</p>

<p>If you are not yet sold on DI, I recommend reading the <a href="https://github.com/google/guice/wiki/Motivation">motivation behind Guice</a>. It uses Java as the base language, but the ideas are the same and apply universally.</p>

<h2>Other approaches</h2>

<p>There are numerous frameworks and approaches implementing DI in various languages and on various platforms. Below are a couple of alternatives to the pure Scala+MacWire approach presented here.</p>

<p>Using frameworks:</p>

<ul>
<li><a href="https://github.com/dickwall/subcut">Subcut</a>: mix of the service locator/dependency injection patterns</li>
<li><a href="http://scaldi.org/">Scaldi</a>: similar to Subcut</li>
<li><a href="http://spring.io/">Spring</a>: Spring is a very popular Java DI framework (and much more). It also works with Scala.</li>
<li><a href="https://github.com/google/guice">Guice</a>: another popular Java DI framework</li>
</ul>

<p>Using pure Scala:</p>

<ul>
<li><a href="http://jonasboner.com/real-world-scala-dependency-injection-di/">Cake pattern</a></li>
<li><a href="http://blog.originate.com/blog/2013/10/21/reader-monad-for-dependency-injection/">Reader monad</a></li>
</ul>

<h2>Running example</h2>

<p>To provide code examples throughout the guide, we will need a running example. </p>

<p>Suppose we are creating a system for a train station. Our goal is to call the method to prepare (load, compose cars) and dispatch the next train. In order to do that, we need to instantiate the following service classes:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">PointSwitcher</span><span class="o">()</span>
<span class="k">class</span> <span class="nc">TrainCarCoupler</span><span class="o">()</span>
<span class="k">class</span> <span class="nc">TrainShunter</span><span class="o">(</span>
   <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span><span class="o">,</span> 
   <span class="n">trainCarCoupler</span><span class="k">:</span> <span class="kt">TrainCarCoupler</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">CraneController</span><span class="o">()</span>
<span class="k">class</span> <span class="nc">TrainLoader</span><span class="o">(</span>
   <span class="n">craneController</span><span class="k">:</span> <span class="kt">CraneController</span><span class="o">,</span> 
   <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">TrainDispatch</span><span class="o">()</span>

<span class="k">class</span> <span class="nc">TrainStation</span><span class="o">(</span>
   <span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span><span class="o">,</span> 
   <span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">,</span> 
   <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span><span class="o">)</span> <span class="o">{</span>

   <span class="k">def</span> <span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>The dependencies of each class are expressed as constructor parameters. The dependencies form an object graph, which needs to be wired.</p>

<p><a name="manual"></a></p>

<p><h1>Manual Dependency Injection</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<p>An approach that is often dismissed too easily is doing dependency injection by hand. While this requires a bit more typing, when doing things manually you are free from any constraints that a framework may impose, and hence a lot of flexibility is gained.</p>

<p>When using DI, we have to somehow create (wire) the object graph, that is create instances of the given classes with the appropriate dependencies. When using a framework, this task is delegated to a container. But nothing keeps us from simply writing the code!</p>

<p>The object graph should be created as late as possible. This may be, for example, the &quot;end of the world&quot;, that is the main class of our application. If you have used DI containers before, when using manual DI with or without MacWire, you will soon re-discover the benefits of having a main method in your application.</p>

<p>To be more specific, here’s a manual-DI version for our example:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">TrainStation</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">pointSwitcher</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PointSwitcher</span><span class="o">()</span>
   <span class="k">val</span> <span class="n">trainCarCoupler</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainCarCoupler</span><span class="o">()</span>
   <span class="k">val</span> <span class="n">trainShunter</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainShunter</span><span class="o">(</span>
      <span class="n">pointSwitcher</span><span class="o">,</span> <span class="n">trainCarCoupler</span><span class="o">)</span>

   <span class="k">val</span> <span class="n">craneController</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CraneController</span><span class="o">()</span>
   <span class="k">val</span> <span class="n">trainLoader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainLoader</span><span class="o">(</span>
      <span class="n">craneController</span><span class="o">,</span> <span class="n">pointSwitcher</span><span class="o">)</span> 

   <span class="k">val</span> <span class="n">trainDispatch</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainDispatch</span><span class="o">()</span>

   <span class="k">val</span> <span class="n">trainStation</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainStation</span><span class="o">(</span>
     <span class="n">trainShunter</span><span class="o">,</span> <span class="n">trainLoader</span><span class="o">,</span> <span class="n">trainDispatch</span><span class="o">)</span>

   <span class="n">trainStation</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div>
<h2>Advantages of Manual DI</h2>

<p>The first advantage of the approach presented above is type-safety: the dependency resolution is done at compile-time, so you can be sure that all dependencies are met.</p>

<p>No run-time reflection is needed, which has a slight startup-time benefit (no need to scan the classpath), but also removes a lot of &quot;magic&quot; from the code. There are no annotations to scan for. We are only using plain Scala, and constructor parameters. It is possible to navigate to the place where the instance is created. The process of creating the object graph is clear. The application is also simple to use, and can be easily packaged e.g. as a fat-jar. No containers to start, no frameworks to fight against.</p>

<p>If creating an instance of some object is complex, or choosing an implementation depends on some configuration, thanks to the flexibility of manual DI, we can easily run arbitrary code which should compute the dependency to use.</p>

<h2><code>val</code> vs. <code>lazy val</code></h2>

<p>Defining dependencies using <code>val</code>s has one drawback: if a dependency is used, before being initialised, it will be <code>null</code> when referenced. That is because <code>val</code>s are calculated from top to bottom.</p>

<p>This can be solved by using <code>lazy val</code>s, which are calculated on-demand, and the right initialisation order will be calculated automatically.</p>

<p>Hence our manual-DI example becomes:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">TrainStation</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">pointSwitcher</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PointSwitcher</span><span class="o">()</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainCarCoupler</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainCarCoupler</span><span class="o">()</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainShunter</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainShunter</span><span class="o">(</span>
      <span class="n">pointSwitcher</span><span class="o">,</span> <span class="n">trainCarCoupler</span><span class="o">)</span>

   <span class="k">lazy</span> <span class="k">val</span> <span class="n">craneController</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CraneController</span><span class="o">()</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainLoader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainLoader</span><span class="o">(</span>
      <span class="n">craneController</span><span class="o">,</span> <span class="n">pointSwitcher</span><span class="o">)</span> 

   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainDispatch</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainDispatch</span><span class="o">()</span> 

   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainStation</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainStation</span><span class="o">(</span>
      <span class="n">trainShunter</span><span class="o">,</span> <span class="n">trainLoader</span><span class="o">,</span> <span class="n">trainDispatch</span><span class="o">)</span> 

   <span class="n">trainStation</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span> 
<span class="o">}</span>
</code></pre></div>
<p><a name="macwire"></a></p>

<p><h1>Using MacWire for wiring</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<p>Manual DI isn’t of course a silver bullet. Manually writing new instance creation code for each class, using the correct parameters may be tedious.</p>

<p>That is where <a href="https://github.com/adamw/macwire">MacWire</a> and the <code>wire</code> method can help. <code>wire</code> is a <a href="http://scalamacros.org/">Scala Macro</a>, which generates the new instance creation code. </p>

<p>After using MacWire, the code becomes simpler:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">TrainStation</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">pointSwitcher</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">PointSwitcher</span><span class="o">]</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainCarCoupler</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainCarCoupler</span><span class="o">]</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainShunter</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainShunter</span><span class="o">]</span>

   <span class="k">lazy</span> <span class="k">val</span> <span class="n">craneController</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">CraneController</span><span class="o">]</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainLoader</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainLoader</span><span class="o">]</span> 
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainDispatch</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainDispatch</span><span class="o">]</span>

   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainStation</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainStation</span><span class="o">]</span>

   <span class="n">trainStation</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span> 
<span class="o">}</span> 
</code></pre></div>
<p>If a new dependency is added to a service or if the order of parameters changes, the object-graph wiring code doesn’t have to be altered; the macro will take care of that. Only when introducing a new service, it must be added to the list.</p>

<p>The new instance creation code is generated by <code>wire</code> at <em>compile time</em>, so if you compare the byte code generated by both examples, it will be identical. The generated code is type-checked in the usual way, so we keep the type-safety of the manual approach.</p>

<p>Usage of the <code>wire</code> macro can be mixed with creating new instances by hand; this may be needed if, as discussed earlier, creating a new instance isn’t that straightforward.</p>

<p>To access <code>wire</code>, you should import <code>com.softwaremill.macwire._</code>. For details on how to integrate MacWire into your project, see the <a href="https://github.com/adamw/macwire">GitHub page</a>.</p>

<h2>How <code>wire</code> works</h2>

<p>Given a class, the <code>wire</code> macro first tries to find a constructor annotated with <code>@Inject</code>, then the (non-private) primary constructor, and finally an <code>apply</code> method in the companion object, to determine the dependencies needed. For each dependency it then looks for a value which conforms to the parameter’s type, in the enclosing method/class/object:</p>

<ul>
<li>first it tries to find a unique value declared as a value in the current block, argument of enclosing methods and anonymous functions</li>
<li>then it tries to find a unique value declared or imported in the enclosing type</li>
<li>finally it tries to find a unique value in parent types (traits/classes)</li>
<li>if the parameter is marked as implicit, it is ignored by MacWire and handled by the normal implicit resolution mechanism</li>
</ul>

<p>Here value can be either a <code>val</code>, <code>lazy val</code> or a no-parameter <code>def</code>, as long as the return type matches.</p>

<p>A compile-time error occurs if:</p>

<ul>
<li>there are multiple values of a given type declared in the enclosing block/method/function&#39;s arguments list, enclosing type or its parents</li>
<li>parameter is marked as implicit and implicit lookup fails to find a value</li>
<li>there is no value of a given type</li>
</ul>

<h2>Using implicit parameters</h2>

<p>A similar effect to the one described above can be achieved by using implicit parameters and implicit values. If all constructor parameters are marked as <code>implicit</code>, and all instances are marked as <code>implicit</code> when the object graph is wired, the Scala compiler will create the proper constructor calls.</p>

<p>The class definitions then become:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">PointSwitcher</span><span class="o">()</span>
<span class="k">class</span> <span class="nc">TrainCarCoupler</span><span class="o">()</span>
<span class="k">class</span> <span class="nc">TrainShunter</span><span class="o">(</span>
   <span class="k">implicit</span>
   <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span><span class="o">,</span> 
   <span class="n">trainCarCoupler</span><span class="k">:</span> <span class="kt">TrainCarCoupler</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">CraneController</span><span class="o">()</span>
<span class="k">class</span> <span class="nc">TrainLoader</span><span class="o">(</span>
   <span class="k">implicit</span>
   <span class="n">craneController</span><span class="k">:</span> <span class="kt">CraneController</span><span class="o">,</span> 
   <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">TrainDispatch</span><span class="o">()</span>

<span class="k">class</span> <span class="nc">TrainStation</span><span class="o">(</span>
   <span class="k">implicit</span>
   <span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span><span class="o">,</span> 
   <span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">,</span> 
   <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span><span class="o">)</span> <span class="o">{</span>

   <span class="k">def</span> <span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>And the wiring:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">TrainStation</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
   <span class="k">implicit</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">pointSwitcher</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PointSwitcher</span>
   <span class="k">implicit</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainCarCoupler</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainCarCoupler</span>
   <span class="k">implicit</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainShunter</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainShunter</span>

   <span class="k">implicit</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">craneController</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CraneController</span>
   <span class="k">implicit</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainLoader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainLoader</span>

   <span class="k">implicit</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainDispatch</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainDispatch</span>

   <span class="k">implicit</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainStation</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainStation</span>

   <span class="n">trainStation</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div>
<p>However, using implicits like that has two drawbacks. First of all, it is intrusive, as you have to mark the constructor parameter list of each class to be wired as <code>implicit</code>. That may not be desireable, and can cause the person reading the code to wonder why the parameters are implicit. </p>

<p>Secondly, implicits are used in many other places in Scala for other, rather different purposes. Adding a large number of implicits as described here may lead to confusion. Still, such a style may be a perfect fit in some use-cases, of course!  </p>

<p><a name="simplescopes"></a></p>

<p><h1>Simple scoping</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<p>So far all of the dependencies have been declared as <code>lazy val</code>s, making them essentially singletons in the scope of a single app usage. Note that these aren’t singletons in the global sense, as we can create multiple copies of the object graph.</p>

<p>However, sometimes we want to create new instances of a dependency for each usage (sometimes called the &quot;dependent scope&quot;). To achieve this, we can simply declare the instance as a <code>def</code>, instead of a <code>lazy val</code>. If, for example, we needed a new instance of the train dispatcher each time, the code would become:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">TrainStation</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">pointSwitcher</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">PointSwitcher</span><span class="o">]</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainCarCoupler</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainCarCoupler</span><span class="o">]</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainShunter</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainShunter</span><span class="o">]</span>

   <span class="k">lazy</span> <span class="k">val</span> <span class="n">craneController</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">CraneController</span><span class="o">]</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainLoader</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainLoader</span><span class="o">]</span>

   <span class="c1">// note the def instead of lazy val</span>
   <span class="k">def</span> <span class="n">trainDispatch</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainDispatch</span><span class="o">]</span> 

   <span class="c1">// the stations share all services except the train dispatch,</span>
   <span class="c1">// for which a new instance is create on each usage</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainStationEast</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainStation</span><span class="o">]</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainStationWest</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainStation</span><span class="o">]</span>

   <span class="n">trainStationEast</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span> 
   <span class="n">trainStationWest</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span> 
<span class="o">}</span>  
</code></pre></div>
<p>Hence, using Scala constructs we can implement two scopes: singleton and dependent.  </p>

<p><a name="modules"></a></p>

<p><h1>Modularising object graph creation</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<h2>Thin cake pattern</h2>

<p>At some point, creating the whole object graph at &quot;the end of the world&quot; will become unpractical, and the code large and hard to read. We should then somehow divide it to smaller pieces. Luckily, Scala’s <code>trait</code>s fit perfectly for that task; they can be used to split the object graph creation code.</p>

<p>In each trait, which for purpose of this task is also called a &quot;module&quot;, part of the object graph is created. Everything is later re-combined by putting all the necessary traits together.</p>

<p>There may be various rules on how to divide code into modules. A good place to start is to consider creating a pre-wired module per-package. Each package should contain a group of classes sharing or implementing some specific functionality. Most probably these classes cooperate in some way, and hence can be wired.</p>

<p>The additional benefit of shipping a package not only with the code, but also with a wired object graph fragment, is that it is more clear how the code should be used. There are no requirements on actually using the wired module, so if needed, wiring can be done in a different way.</p>

<p>However, such modules can’t usually exist stand-alone: very often they will depend on some classes from other modules. There are two ways of expressing dependencies.</p>

<h2>Expressing dependencies via abstract members</h2>

<p>As each module is a trait, it is possible to leave some dependencies undefined, as abstract members. Such abstract members can be used when wiring (either manually or using the <code>wire</code> macro), but the specific implementation doesn’t have to be given.</p>

<p>When all the modules are combined in the end application, the compiler will verify that all such dependencies defined as abstract members are defined.</p>

<p>Note that we can declare all abstract members as <code>def</code>s, as they can be later implemented as <code>val</code>s, <code>lazy val</code>s, or left as <code>def</code>s. Using a <code>def</code> keeps all options possible.</p>

<p>The wiring for our example code can be divided as follows; the classes are now grouped into packages:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">shunting</span> <span class="o">{</span>
   <span class="k">class</span> <span class="nc">PointSwitcher</span><span class="o">()</span>
   <span class="k">class</span> <span class="nc">TrainCarCoupler</span><span class="o">()</span>
   <span class="k">class</span> <span class="nc">TrainShunter</span><span class="o">(</span>
      <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span><span class="o">,</span> 
      <span class="n">trainCarCoupler</span><span class="k">:</span> <span class="kt">TrainCarCoupler</span><span class="o">)</span>
<span class="o">}</span> 

<span class="k">package</span> <span class="nn">loading</span> <span class="o">{</span>
   <span class="k">class</span> <span class="nc">CraneController</span><span class="o">()</span>
   <span class="k">class</span> <span class="nc">TrainLoader</span><span class="o">(</span>
      <span class="n">craneController</span><span class="k">:</span> <span class="kt">CraneController</span><span class="o">,</span> 
      <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">package</span> <span class="nn">station</span> <span class="o">{</span>
   <span class="k">class</span> <span class="nc">TrainDispatch</span><span class="o">()</span>

   <span class="k">class</span> <span class="nc">TrainStation</span><span class="o">(</span>
      <span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span><span class="o">,</span> 
      <span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">,</span> 
      <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span><span class="o">)</span> <span class="o">{</span>

      <span class="k">def</span> <span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span> 
</code></pre></div>
<p>Each package has a corresponding trait-module. Note that the dependency between the <code>shunting</code> and <code>loading</code> packages is expressed using an abstract member:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">shunting</span> <span class="o">{</span>
   <span class="k">trait</span> <span class="nc">ShuntingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">pointSwitcher</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">PointSwitcher</span><span class="o">]</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainCarCoupler</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainCarCoupler</span><span class="o">]</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainShunter</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainShunter</span><span class="o">]</span> 
   <span class="o">}</span>
<span class="o">}</span>

<span class="k">package</span> <span class="nn">loading</span> <span class="o">{</span>
   <span class="k">trait</span> <span class="nc">LoadingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">craneController</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">CraneController</span><span class="o">]</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainLoader</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainLoader</span><span class="o">]</span> 

      <span class="c1">// dependency of the module</span>
      <span class="k">def</span> <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="k">package</span> <span class="nn">station</span> <span class="o">{</span>
   <span class="k">trait</span> <span class="nc">StationModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainDispatch</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainDispatch</span><span class="o">]</span>

      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainStation</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainStation</span><span class="o">]</span>

      <span class="c1">// dependencies of the module</span>
      <span class="k">def</span> <span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span> 
      <span class="k">def</span> <span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">TrainStation</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">modules</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ShuntingModule</span>
      <span class="k">with</span> <span class="nc">LoadingModule</span>
      <span class="k">with</span> <span class="nc">StationModule</span>

   <span class="n">modules</span><span class="o">.</span><span class="n">trainStation</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span>   
<span class="o">}</span>  
</code></pre></div>
<p>To implement dependencies this way a consistent naming convention is needed, as the abstract member is reconciled with the implementation by-name. Naming the values same as the classes, but with the initial letter lowercase is a good example of such a convention.</p>

<p>This approach is in some parts similar to the Cake Pattern, hence the name: <strong>Thin Cake Pattern</strong>.</p>

<h2>Expressing dependencies via self-types</h2>

<p>Another way of expressing dependencies is by using self-types or extending other trait-modules. This way creates a much stronger connection between the two modules, instead of the looser coupled abstract member approach, however in some situations is desirable (e.g. when having a module-interface with multiple implementations, see below).</p>

<p>For example, we could express the dependency between the shunting and loading modules and the station module by extending trait-module, instead of using the abstract members:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">shunting</span> <span class="o">{</span>
   <span class="k">trait</span> <span class="nc">ShuntingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">pointSwitcher</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">PointSwitcher</span><span class="o">]</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainCarCoupler</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainCarCoupler</span><span class="o">]</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainShunter</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainShunter</span><span class="o">]</span> 
   <span class="o">}</span>
<span class="o">}</span>

<span class="k">package</span> <span class="nn">loading</span> <span class="o">{</span>
   <span class="k">trait</span> <span class="nc">LoadingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">craneController</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">CraneController</span><span class="o">]</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainLoader</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainLoader</span><span class="o">]</span> 

      <span class="c1">// dependency expressed using an abstract member</span>
      <span class="k">def</span> <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="k">package</span> <span class="nn">station</span> <span class="o">{</span>
   <span class="c1">// dependencies expressed using extends</span>
   <span class="k">trait</span> <span class="nc">StationModule</span> <span class="k">extends</span> <span class="nc">ShuntingModule</span> <span class="k">with</span> <span class="nc">LoadingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainDispatch</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainDispatch</span><span class="o">]</span>

      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainStation</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainStation</span><span class="o">]</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">TrainStation</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">modules</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ShuntingModule</span>
      <span class="k">with</span> <span class="nc">LoadingModule</span>
      <span class="k">with</span> <span class="nc">StationModule</span>

   <span class="n">modules</span><span class="o">.</span><span class="n">trainStation</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span>   
<span class="o">}</span>   
</code></pre></div>
<p>A very similar effect would be achieved by using a self-type. </p>

<p>This approach can also be useful to create bigger modules out of multiple smaller ones, without the need to re-express the dependencies of the smaller modules. Simply define a bigger-module-trait extending a number of smaller-module-traits.</p>

<h2>Composing modules</h2>

<p>Modules can be also combined using composition, that is you can nest modules as members and use dependencies defined in the nested modules to wire objects.</p>

<p>For example, we can add a plugin to our train management application which will allow gathering statistics:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">stats</span> <span class="o">{</span>
   <span class="k">class</span> <span class="nc">LoadingStats</span><span class="o">(</span><span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">)</span>
   <span class="k">class</span> <span class="nc">ShuntingStats</span><span class="o">(</span><span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span><span class="o">)</span>

   <span class="k">class</span> <span class="nc">StatsModule</span><span class="o">(</span>
      <span class="n">shuntingModule</span><span class="k">:</span> <span class="kt">ShuntingModule</span><span class="o">,</span>
      <span class="n">loadingModule</span><span class="k">:</span> <span class="kt">LoadingModule</span><span class="o">)</span> <span class="o">{</span>

      <span class="k">import</span> <span class="nn">shuntingModule._</span>
      <span class="k">import</span> <span class="nn">loadingModule._</span>

      <span class="k">lazy</span> <span class="k">val</span> <span class="n">loadingStats</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">LoadingStats</span><span class="o">]</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">shuntingStats</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">ShuntingStats</span><span class="o">]</span>    
   <span class="o">}</span>   
<span class="o">}</span>
</code></pre></div>
<p>Note the <code>import</code> statements, which bring any dependencies defined in the nested modules into scope.</p>

<p>This can be further shortened by using an experimental <code>@Module</code> annotation for module <code>trait</code>s/<code>class</code>es; members of nested modules with that annotaiton will be taken into account automatically during wiring:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">loading</span> <span class="o">{</span>
   <span class="nd">@Module</span>
   <span class="k">trait</span> <span class="nc">LoadingModule</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>

<span class="k">package</span> <span class="nn">shunting</span> <span class="o">{</span>
   <span class="nd">@Module</span>
   <span class="k">trait</span> <span class="nc">ShuntingModule</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>

<span class="k">package</span> <span class="nn">stats</span> <span class="o">{</span>
   <span class="k">class</span> <span class="nc">LoadingStats</span><span class="o">(</span><span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">)</span>
   <span class="k">class</span> <span class="nc">ShuntingStats</span><span class="o">(</span><span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span><span class="o">)</span>

   <span class="k">class</span> <span class="nc">StatsModule</span><span class="o">(</span>
      <span class="n">shuntingModule</span><span class="k">:</span> <span class="kt">ShuntingModule</span><span class="o">,</span>
      <span class="n">loadingModule</span><span class="k">:</span> <span class="kt">LoadingModule</span><span class="o">)</span> <span class="o">{</span>

      <span class="k">lazy</span> <span class="k">val</span> <span class="n">loadingStats</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">LoadingStats</span><span class="o">]</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">shuntingStats</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">ShuntingStats</span><span class="o">]</span>    
   <span class="o">}</span>   
<span class="o">}</span>
</code></pre></div>
<p>In this scenario no imports are necessary.  </p>

<p><a name="multiple"></a></p>

<p><h1>Multiple implementations</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<p>Often there are cases when we have multiple implementations for some functionality, and we need to choose one depending on configuration. This can be modelled in at least two ways.</p>

<p>Firstly, we can have a single module, which contains conditional logic choosing the right implementation. Suppose we have two options for train shunting, either the traditional one, or using teleportation, and a config flag:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">shunting</span> <span class="o">{</span>
   <span class="k">trait</span> <span class="nc">TrainShunter</span>

   <span class="k">class</span> <span class="nc">PointSwitcher</span><span class="o">()</span>
   <span class="k">class</span> <span class="nc">TrainCarCoupler</span><span class="o">()</span>
   <span class="k">class</span> <span class="nc">TraditionalTrainShunter</span><span class="o">(</span>
      <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span><span class="o">,</span>
      <span class="n">trainCarCoupler</span><span class="k">:</span> <span class="kt">TrainCarCoupler</span><span class="o">)</span> 
      <span class="k">extends</span> <span class="nc">TrainShunter</span>

   <span class="k">class</span> <span class="nc">TeleportingTrainShunter</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">TrainShunter</span>

   <span class="k">trait</span> <span class="nc">ShuntingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">pointSwitcher</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">PointSwitcher</span><span class="o">]</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainCarCoupler</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainCarCoupler</span><span class="o">]</span>

      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainShunter</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="n">modern</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">wire</span><span class="o">[</span><span class="kt">TeleportingTrainShunter</span><span class="o">]</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
         <span class="n">wire</span><span class="o">[</span><span class="kt">TraditionalTrainShunter</span><span class="o">]</span>
      <span class="o">}</span>  

      <span class="k">def</span> <span class="n">config</span><span class="k">:</span> <span class="kt">Config</span>
   <span class="o">}</span>
<span class="o">}</span>  
</code></pre></div>
<p>Secondly, a module can have multiple implementations. In such a case, we can create an interface-module containing only abstract members, which are implemented in the proper modules. Such an interface-module can also be very useful for expressing dependencies (without relying on a naming convention), and creating very strong links:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">shunting</span> <span class="o">{</span>
   <span class="k">trait</span> <span class="nc">TrainShunter</span>

   <span class="k">class</span> <span class="nc">PointSwitcher</span><span class="o">()</span>
   <span class="k">class</span> <span class="nc">TrainCarCoupler</span><span class="o">()</span>
   <span class="k">class</span> <span class="nc">TraditionalTrainShunter</span><span class="o">(</span>
      <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span><span class="o">,</span> 
      <span class="n">trainCarCoupler</span><span class="k">:</span> <span class="kt">TrainCarCoupler</span><span class="o">)</span> 
      <span class="k">extends</span> <span class="nc">TrainShunter</span>

   <span class="k">class</span> <span class="nc">TeleportingTrainShunter</span><span class="o">()</span> <span class="k">extends</span> <span class="nc">TrainShunter</span>

   <span class="k">trait</span> <span class="nc">ShuntingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">pointSwitcher</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">PointSwitcher</span><span class="o">]</span>

      <span class="k">def</span> <span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span>
   <span class="o">}</span>

   <span class="k">trait</span> <span class="nc">TraditionalShuntingModule</span> <span class="k">extends</span> <span class="nc">ShuntingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainCarCoupler</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainCarCoupler</span><span class="o">]</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainShunter</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TraditionalTrainShunter</span><span class="o">]</span>
   <span class="o">}</span>

   <span class="k">trait</span> <span class="nc">ModernShuntingModule</span> <span class="k">extends</span> <span class="nc">ShuntingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainShunter</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TeleportingTrainShunter</span><span class="o">]</span>
   <span class="o">}</span> 
<span class="o">}</span>  

<span class="c1">// ...</span>

<span class="k">object</span> <span class="nc">TrainStation</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">traditionalModules</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TraditionalShuntingModule</span>
      <span class="k">with</span> <span class="nc">LoadingModule</span>
      <span class="k">with</span> <span class="nc">StationModule</span>

   <span class="k">val</span> <span class="n">modernModules</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ModernShuntingModule</span>
      <span class="k">with</span> <span class="nc">LoadingModule</span>
      <span class="k">with</span> <span class="nc">StationModule</span> 

   <span class="n">traditionalModules</span><span class="o">.</span><span class="n">trainStation</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span>   
   <span class="n">modernModules</span><span class="o">.</span><span class="n">trainStation</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span>   
<span class="o">}</span> 
</code></pre></div>
<p>The downside of this approach is that the module stack must be known at compile time (cannot be chosen dynamically). While it is possible to create 2 or 4 different stacks for a couple of config options, with increasing config options the number of stacks grows exponentially.</p>

<p>The interface-trait-module and implementation-trait-module is in fact part of the approach taken by the Cake Pattern for expressing dependencies. However this results in quite a lot of boilerplate code, so it’s good to use only when needed.   </p>

<p><a name="testing"></a></p>

<p><h1>Testing</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<p>Individual components can be tested by providing mock/stub implementations of some of the dependencies.</p>

<p>Moreover, when using the thin cake pattern, modules can be integration-tested, using the wiring defined in the module.</p>

<p>Of course, we will need to provide some implementation (again, can be a mock/stub), for any dependencies expressed as abstract members. However, it is also possible to override some of the dependencies, to provide alternative implementations for testing. These implementations will be used to wire the graph fragment defined in the module.</p>

<p>For example, to test our shunting module, we could mock the point switcher, which interacts with some external systems, and write an integration test:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="c1">// main code</span>
<span class="k">package</span> <span class="nn">shunting</span> <span class="o">{</span>
   <span class="k">trait</span> <span class="nc">ShuntingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">pointSwitcher</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">PointSwitcher</span><span class="o">]</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainCarCoupler</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainCarCoupler</span><span class="o">]</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainShunter</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainShunter</span><span class="o">]</span> 
   <span class="o">}</span>
<span class="o">}</span> 

<span class="c1">// test</span>
<span class="k">class</span> <span class="nc">ShuntingModuleItTest</span> <span class="k">extends</span> <span class="nc">FlatSpec</span> <span class="o">{</span>
   <span class="n">it</span> <span class="n">should</span> <span class="s">&quot;work&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="c1">// given</span>
      <span class="k">val</span> <span class="n">mockPointSwitcher</span> <span class="k">=</span> <span class="n">mock</span><span class="o">[</span><span class="kt">PointSwitcher</span><span class="o">]</span>

      <span class="c1">// when</span>
      <span class="k">val</span> <span class="n">moduleToTest</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ShuntingModule</span> <span class="o">{</span>
         <span class="c1">// the mock implementation will be used to wire the graph</span>
         <span class="k">override</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">pointSwitcher</span> <span class="k">=</span> <span class="n">mockPointSwitcher</span>
      <span class="o">}</span>
      <span class="n">moduleToTest</span><span class="o">.</span><span class="n">trainShunter</span><span class="o">.</span><span class="n">shunt</span><span class="o">()</span>

      <span class="c1">// then</span>
      <span class="n">verify</span><span class="o">(</span><span class="n">mockPointSwitcher</span><span class="o">).</span><span class="n">switch</span><span class="o">(...)</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><a name="interceptors"></a></p>

<p><h1>Interceptors</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<p>Interceptors are very useful for implementing cross-cutting concerns, and are a part of almost every DI framework/container. While there’s no direct support for interceptors in Scala, with a thin library layer (provided by MacWire), it is easy to write and use interceptors.</p>

<p>Using interceptors is a two-step process. First, we have to declare <em>what</em> should be intercepted. Ideally, this shouldn’t involve the implementation of the interceptor in any way. Secondly, we have to define what the interceptor does - the behaviour.</p>

<p>To implement the first part, we will define an abstract interceptor, and apply it to selected values. Let’s say that we want to audit all point switches and car couplings events to some external system. To do that, we need to intercept all method calls on the <code>PointSwitcher</code> and <code>TrainCarCoupler</code> services:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">shunting</span> <span class="o">{</span>
   <span class="k">trait</span> <span class="nc">ShuntingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span> <span class="o">=</span> 
            <span class="n">logEvents</span><span class="o">(</span><span class="n">wire</span><span class="o">[</span><span class="kt">PointSwitcher</span><span class="o">])</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainCarCoupler</span><span class="k">:</span> <span class="kt">TrainCarCoupler</span> <span class="o">=</span> 
            <span class="n">logEvents</span><span class="o">(</span><span class="n">wire</span><span class="o">[</span><span class="kt">TrainCarCoupler</span><span class="o">])</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainShunter</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainShunter</span><span class="o">]</span> 

      <span class="k">def</span> <span class="n">logEvents</span><span class="k">:</span> <span class="kt">Interceptor</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>We have <em>declared</em> that we want to apply the <code>logEvents</code> interceptor to the <code>pointSwitcher</code> and <code>trainCarCoupler</code> services. Note that so far the implementation hasn’t been mentioned in any way. We are only using the abstract <code>Interceptor</code> trait, which has an <code>apply</code> method, returning an instance of the same type, as passed to it through the parameter.</p>

<p>At some point we of course have to specify the implementation. We can do this as late as possible, the last point being the main entry point to the application: </p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">TrainStation</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">modules</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ShuntingModule</span>
      <span class="k">with</span> <span class="nc">LoadingModule</span>
      <span class="k">with</span> <span class="nc">StationModule</span> <span class="o">{</span>

      <span class="k">lazy</span> <span class="k">val</span> <span class="n">logEvents</span> <span class="k">=</span> <span class="nc">ProxyingInterceptor</span> <span class="o">{</span> <span class="n">ctx</span> <span class="k">=&gt;</span>
         <span class="n">println</span><span class="o">(</span><span class="s">&quot;Calling method: &quot;</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">getName</span><span class="o">())</span>
         <span class="n">ctx</span><span class="o">.</span><span class="n">proceed</span><span class="o">()</span>
      <span class="o">}</span>
   <span class="o">}</span>

   <span class="n">modules</span><span class="o">.</span><span class="n">trainStation</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span>   
<span class="o">}</span>   
</code></pre></div>
<p>Here we have specified that we want to create a proxying interceptor (which will create a Java proxy), with the given behaviour on method invocation. Note that we could use any of the services defined in the modules, when handling the proxied call.</p>

<p>For testing, it may be useful to skip interceptors. This can also easily be done by providing a no-op interceptor implementation:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">ShuntingModuleItTest</span> <span class="k">extends</span> <span class="nc">FlatSpec</span> <span class="o">{</span>
   <span class="n">it</span> <span class="n">should</span> <span class="s">&quot;work&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="c1">// given</span>
      <span class="k">val</span> <span class="n">moduleToTest</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ShuntingModule</span> <span class="o">{</span>
         <span class="k">lazy</span> <span class="k">val</span> <span class="n">logEvents</span> <span class="k">=</span> <span class="nc">NoOpInterceptor</span>
      <span class="o">}</span>

      <span class="c1">// ...</span>
   <span class="o">}</span>
<span class="o">}</span> 
</code></pre></div>
<p><a name="advscopes"></a></p>

<p><h1>Advanced scoping</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<p>Especially in web applications, it is useful to have scopes other than singleton and dependent - e.g. scopes tied to the duration of a request, or scopes tied to a user sessions. </p>

<p>Like interceptors, a lot of the DI containers/frameworks contain support for different scopes. They may seem &quot;magical&quot;, however they are in fact pretty simple.</p>

<p>MacWire contains a general skeleton for defining scopes, similar to interceptors. The <code>Scope</code> trait defines two methods: <code>apply</code>, which when applied to an instance should create a scoped value, and <code>get</code>, to get the current underlying value of the scope. The scope’s life cycle is entirely managed by the implementor.</p>

<p>Similarly to interceptors, usage of scopes is declarative, by using an abstract <code>Scope</code> value, and the definition can be provided as late as in the main application entry point.</p>

<p>For example, in a Java servlet-based web project, to make the train dispatch session-scoped (new dispatch for each session), we would first need to declare the usage of the session scope:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">station</span> <span class="o">{</span>
   <span class="k">trait</span> <span class="nc">StationModule</span> <span class="k">extends</span> <span class="nc">ShuntingModule</span> <span class="k">with</span> <span class="nc">LoadingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span> <span class="o">=</span> 
            <span class="n">session</span><span class="o">(</span><span class="n">wire</span><span class="o">[</span><span class="kt">TrainDispatch</span><span class="o">])</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainStation</span><span class="k">:</span> <span class="kt">TrainStation</span> <span class="o">=</span> 
            <span class="n">wire</span><span class="o">[</span><span class="kt">TrainStation</span><span class="o">]</span>

      <span class="k">def</span> <span class="n">session</span><span class="k">:</span> <span class="kt">Scope</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>When starting the application, we need to provide the implementation of the scope. Two implementations are shipped by default, a <code>NoOpScope</code> (useful for testing), and a <code>ThreadLocalScope</code>, which holds the &quot;current&quot; scoped value in a thread-local variable (hence this implementation is only useful for synchronous web frameworks); the thread-local scope needs to be associated with a storage before each request:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">object</span> <span class="nc">TrainStation</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">modules</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ShuntingModule</span>
      <span class="k">with</span> <span class="nc">LoadingModule</span>
      <span class="k">with</span> <span class="nc">StationModule</span> <span class="o">{</span>

      <span class="k">lazy</span> <span class="k">val</span> <span class="n">session</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ThreadLocalScope</span>
   <span class="o">}</span>

   <span class="c1">// implement a filter which attaches the session to the scope</span>
   <span class="c1">// use the filter in the server</span>

   <span class="n">modules</span><span class="o">.</span><span class="n">trainStation</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span>   
<span class="o">}</span>   
</code></pre></div>
<p>For an example session scope implementation, see the <a href="https://github.com/adamw/macwire">MacWire</a> site.  </p>

<p><a name="factories"></a></p>

<p><h1>Factories</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<h2>Factories as functions</h2>

<p>In the simplest form, a factory is a function: a parametrized way to create an object. You can also think of it as a partially wired dependency.</p>

<p>Let&#39;s say the <code>TrainLoader</code> additionally requires a <code>CarLoader</code> dependency parametrized by <code>CarType</code> (the type of the train car to load: coal, refrigerated, chemical etc.). As a convenience, we can create a type alias for the function, but that is entirerly optional. The definition of the <code>TrainLoader</code> class now becomes:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">type</span> <span class="kt">CarLoaderFactory</span> <span class="o">=</span> <span class="nc">CarType</span> <span class="k">=&gt;</span> <span class="nc">CarLoader</span>

<span class="k">class</span> <span class="nc">TrainLoader</span><span class="o">(</span>
   <span class="n">craneController</span><span class="k">:</span> <span class="kt">CraneController</span><span class="o">,</span> 
   <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span><span class="o">,</span>
   <span class="n">carLoaderFactory</span><span class="k">:</span> <span class="kt">CarLoaderFactory</span><span class="o">)</span>
</code></pre></div>
<p>We can now wire <code>TrainLoader</code> as usual (either manually or using MacWire), however of course we need a dependency of type <code>CarLoaderFactory</code> defined somewhere; extending the <code>LoadingModule</code> we get:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">LoadingModule</span> <span class="o">{</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">craneController</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">CraneController</span><span class="o">]</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainLoader</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainLoader</span><span class="o">]</span> 

   <span class="k">lazy</span> <span class="k">val</span> <span class="n">carLoaderFactory</span> <span class="k">=</span> <span class="o">(</span><span class="n">ct</span><span class="k">:</span> <span class="kt">CarType</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">wire</span><span class="o">[</span><span class="kt">CarLoader</span><span class="o">]</span>
   <span class="c1">// the above wire will expand to: new CarLoader(ct). Can also </span>
   <span class="c1">// be any other logic to instantiate a CarLoader</span>

   <span class="c1">// dependency of the module</span>
   <span class="k">def</span> <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span>
<span class="o">}</span>
</code></pre></div>
<h2>Factories in trait-modules</h2>

<p>You can also create factories by defining methods directly in the trait-modules. The method parameters will be also used for wiring when using <code>wire[]</code>.</p>

<p>Let&#39;s say the <code>TrainStation</code> requires a name:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">TrainStation</span><span class="o">(</span>
   <span class="n">name</span><span class="k">:</span> <span class="kt">Name</span><span class="o">,</span>
   <span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span><span class="o">,</span> 
   <span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">,</span> 
   <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span><span class="o">)</span> <span class="o">{</span>

   <span class="k">def</span> <span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>We can expose a parametrized train station in the module by defining a method with a name parameter:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">StationModule</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">trainStation</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">Name</span><span class="o">)</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainStation</span><span class="o">]</span>

      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainDispatch</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainDispatch</span><span class="o">]</span>

      <span class="c1">// dependencies of the module</span>
      <span class="k">def</span> <span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span> 
      <span class="k">def</span> <span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span>
<span class="o">}</span>
</code></pre></div>
<p>When retrieving an instance of a train station from the combined modules, we now have to provide a name. The method parameters, together with other dependencies looked up in the usual way, will be used to create a <code>TrainStation</code> instance.</p>

<h2>Wiring using factory methods</h2>

<p>Using MacWire, it is also possible to wire objects with a factory method instead of a constructor. For example, suppose that instances of <code>TrainLoader</code> needs to be created using a special method which passes some numeric parameters to the crane; in such situations, we can use <code>wireWith</code>:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">package</span> <span class="nn">loading</span> <span class="o">{</span>
   <span class="k">class</span> <span class="nc">TrainLoader</span><span class="o">(</span>
      <span class="n">craneController</span><span class="k">:</span> <span class="kt">CraneController</span><span class="o">,</span> 
      <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span><span class="o">,</span>
      <span class="n">xAxisCoefficient</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span>
      <span class="n">yAxisCoefficient</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>

   <span class="k">object</span> <span class="nc">TrainLoader</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">createDefault</span><span class="o">(</span>
         <span class="n">craneController</span><span class="k">:</span> <span class="kt">CraneController</span><span class="o">,</span> 
         <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span><span class="o">)</span> <span class="k">=</span>
         <span class="k">new</span> <span class="nc">TrainLoader</span><span class="o">(</span><span class="n">craneController</span><span class="o">,</span> <span class="n">pointSwitcher</span><span class="o">,</span>
            <span class="mf">10.0</span><span class="o">,</span> <span class="mf">12.5</span><span class="o">)</span> 
   <span class="o">}</span>  

   <span class="k">trait</span> <span class="nc">LoadingModule</span> <span class="o">{</span>
      <span class="k">lazy</span> <span class="k">val</span> <span class="n">craneController</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">CraneController</span><span class="o">]</span>

      <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainLoader</span> <span class="k">=</span> <span class="n">wireWith</span><span class="o">(</span><span class="nc">TrainLoader</span><span class="o">.</span><span class="n">createDefault</span><span class="o">)</span> 

      <span class="c1">// dependency of the module</span>
      <span class="k">def</span> <span class="n">pointSwitcher</span><span class="k">:</span> <span class="kt">PointSwitcher</span>
   <span class="o">}</span> 
<span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p><a name="dynamic"></a></p>

<p><h1>Accessing the object graph dynamically</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<p>While it would be great to be able to define in a type-safe way the whole object graph for an application upfront, there are cases when it is necessary to access and extend it dynamically. </p>

<p>First use-case is when integrating with web frameworks. There it is often needed to access a wired instance by-class. Second use-case is dynamically creating instances of classes, which names are only known at run-time, such as plugins. </p>

<p>Both of these use-cases are realised by the <code>Wired</code> class, which can be created given an instance of a module, containing the object graph, using the <code>wiredInModule</code> macro. Any <code>val</code>s, <code>lazy val</code>s and parameter-less <code>def</code>s will be available. </p>

<p>If our train station management application had a plugin system, which could use any of the dependencies in the object graph, we could instantiate the plugins as follows:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">TrainStationPlugin</span> <span class="o">{</span>
   <span class="k">def</span> <span class="n">init</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">TrainStation</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
   <span class="k">val</span> <span class="n">modules</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ShuntingModule</span>
      <span class="k">with</span> <span class="nc">LoadingModule</span>
      <span class="k">with</span> <span class="nc">StationModule</span>

   <span class="k">val</span> <span class="n">wired</span> <span class="k">=</span> <span class="n">wiredInModule</span><span class="o">(</span><span class="n">modules</span><span class="o">)</span>

   <span class="k">val</span> <span class="n">plugins</span> <span class="k">=</span> <span class="n">config</span><span class="o">.</span><span class="n">pluginClasses</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">pluginClass</span> <span class="k">=&gt;</span>
      <span class="n">wired</span>
         <span class="o">.</span><span class="n">wireClassInstanceByName</span><span class="o">(</span><span class="n">pluginClass</span><span class="o">)</span>
         <span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">TrainStationPlugin</span><span class="o">]</span>
   <span class="o">}</span>

   <span class="n">plugins</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">init</span><span class="o">())</span>

   <span class="n">modules</span><span class="o">.</span><span class="n">trainStation</span><span class="o">.</span><span class="n">prepareAndDispatchNextTrain</span><span class="o">()</span>   
<span class="o">}</span>   
</code></pre></div>
<p>An instance of <code>Wired</code> can be also extended with new instances and instance factories, using the <code>withInstances</code> and <code>withInstanceFactory</code> methods.</p>

<p>For an example of integrating Dependency Injection and MacWire with Play! Framework, see the <a href="http://typesafe.com/activator/template/macwire-activator">Play+MacWire</a> activator.  </p>

<p><a name="multipleinst"></a></p>

<p><h1>Multiple instances</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<p>In some cases we have a couple of objects of the same type that we want to use as dependencies. For example, assume that our train station now needs two train loaders, one for regular freight, one for liquid freight:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">TrainStation</span><span class="o">(</span>
   <span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span><span class="o">,</span> 
   <span class="n">regularTrainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">,</span>  
   <span class="n">liquidTrainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">,</span> 
   <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div>
<p>In our wiring code we then need to create the two instances:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">lazy</span> <span class="k">val</span> <span class="n">regularTrainLoader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainLoader</span><span class="o">(...)</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="n">liquidTrainLoader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainLoader</span><span class="o">(...)</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="n">trainStation</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainStation</span><span class="o">(</span>
   <span class="n">trainShunter</span><span class="o">,</span>
   <span class="n">regularTrainLoader</span><span class="o">,</span>
   <span class="n">liquidTrainLoader</span><span class="o">,</span>
   <span class="n">trainDispatch</span><span class="o">)</span>
</code></pre></div>
<p>This is a perfectly good solution if we are using manual dependency injection - everything works as expected. One downside is that it&#39;s not entirely type-safe: if we mix-up the regular and liquid train loaders when passing them as arguments to the <code>TrainStation</code> constructor, everything will still compile just fine.</p>

<p>However, if we try to use MacWire (or implicits), compilation will fail: MacWire has no chances of knowing, which instance should be used where. We need to somehow differentiate the instances so that the compiler will be able to tell which goes where.</p>

<h2>Using different types</h2>

<p>The first solution is to give the two dependencies distinct types, however of course that is not always possible. In our case, these might be for example traits, or subclasses:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">TrainStation</span><span class="o">(</span>
   <span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span><span class="o">,</span> 
   <span class="n">regularTrainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span> <span class="kt">with</span> <span class="kt">Regular</span><span class="o">,</span>  
   <span class="n">liquidTrainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span> <span class="kt">with</span> <span class="kt">Liquid</span><span class="o">,</span> 
   <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="n">regularTrainLoader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainLoader</span><span class="o">(...)</span> <span class="k">with</span> <span class="nc">Regular</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="n">liquidTrainLoader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TrainLoader</span><span class="o">(...)</span> <span class="k">with</span> <span class="nc">Liquid</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="n">trainStation</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainStation</span><span class="o">]</span>
</code></pre></div>
<p>This is also a type-safe solution, we are now <strong>not</strong> able to mix up the two dependencies when passing them as arguments to <code>TrainStation</code>.</p>

<h2>Using qualifiers/tags</h2>

<p>Another solution is to use tagging from MacWire, which is inspired by the work of <a href="https://gist.github.com/milessabin/89c9b47a91017973a35f">Miles Sabin</a> and what is present in <a href="https://github.com/scalaz/scalaz">Scalaz</a>. </p>

<p>A tag is a Scala trait, usually an empty one. An instance of type <code>X</code> tagged with tag <code>T</code> has type <code>X @@ T</code>, or <code>Tagged[X, T]</code>, depending which syntax you prefer. You can add tags to instances using the <code>x.taggedWith[T]</code> method available on any type. All these declarations can be brough into scope by importing <code>com.softwaremill.macwire._</code>.</p>

<p>The tags follow proper subtyping rules: <code>X &lt;: X @@ T</code>, so you can use a tagged instance if an untagged one is required. On the other hand, <code>X @@ T1</code> is not a subtype of <code>X @@ T2</code> if <code>T1</code> and <code>T2</code> are distinct, so you are safe from using the wrong instance with the wrong tag. </p>

<p>Tags incur zero runtime overhead, they are a purely compile-time construct.</p>

<p>Our train station dependencies and wiring can then be expressed in the following way:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">trait</span> <span class="nc">Regular</span>
<span class="k">trait</span> <span class="nc">Liquid</span>

<span class="k">class</span> <span class="nc">TrainStation</span><span class="o">(</span>
   <span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span><span class="o">,</span> 
   <span class="n">regularTrainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span> <span class="kt">@@</span> <span class="kt">Regular</span><span class="o">,</span>  
   <span class="n">liquidTrainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span> <span class="kt">@@</span> <span class="kt">Liquid</span><span class="o">,</span> 
   <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="k">lazy</span> <span class="k">val</span> <span class="n">regularTrainLoader</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainLoader</span><span class="o">].</span><span class="n">taggedWith</span><span class="o">[</span><span class="kt">Regular</span><span class="o">]</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="n">liquidTrainLoader</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainLoader</span><span class="o">].</span><span class="n">taggedWith</span><span class="o">[</span><span class="kt">Liquid</span><span class="o">]</span>
<span class="k">lazy</span> <span class="k">val</span> <span class="n">trainStation</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainStation</span><span class="o">]</span>
</code></pre></div>
<p>Note that you can use any form of &quot;tagging&quot; instances (e.g. the one from Scalaz), MacWire does not require to use the tags from its distribution. The only thing MacWire does during wiring is regular Scala subtype checks.</p>

<p><a name="akka"></a></p>

<p><h1>DI in Akka</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<p><a href="http://akka.io">Akka</a> is a very popular toolkit for building concurrent, &quot;reactive&quot; applications. The main building block used in Akka-based systems are actors. A common question when using Akka is &quot;how do I do dependency injection with actors?&quot;; typical use-case is passing a datasource to an actor.</p>

<h2>Injecting services</h2>

<p>The current best-practice for defining actor instantion code, when the actor instance needs some external dependencies, is to provide a method in the companion object returning the <code>Props</code> describing how to create a new actor instance (remember, actor instances can be created multiple times, even if it&#39;s a &quot;singleton&quot; actor!):</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span><span class="nc">Actor</span><span class="o">,</span> <span class="nc">Props</span><span class="o">}</span>

<span class="k">class</span> <span class="nc">ReactiveTrainDispatch</span><span class="o">(</span>
   <span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">,</span> 
   <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>

   <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">ReactiveTrainDispatch</span> <span class="o">{</span>
   <span class="k">def</span> <span class="n">props</span><span class="o">(</span><span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">,</span> <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span><span class="o">)</span> <span class="k">=</span> 
      <span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">ReactiveTrainDispatch</span><span class="o">(</span><span class="n">trainLoader</span><span class="o">,</span> <span class="n">trainDispatch</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div>
<p>When using MacWire, we could already simplify this code a bit by using <code>wire</code> inside of <code>Props</code>: <code>Props(wire[ReactiveTrainDispatch])</code>. However, we still need to repeat all the dependencies in the <code>props</code> method signature.</p>

<p>An alternative is to move the props-creating code into a <a href="#modules">trait-module</a> (assuming that <code>ReactiveTrainDispatch</code> lives in the <code>station</code> package):</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">ReactiveTrainDispatch</span><span class="o">(</span>
   <span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">,</span> 
   <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>

   <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">StationModule</span> <span class="o">{</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">reactiveTrainDispatchProps</span> <span class="k">=</span> 
      <span class="nc">Props</span><span class="o">(</span><span class="n">wire</span><span class="o">[</span><span class="kt">ReactiveTrainDispatch</span><span class="o">])</span> 

   <span class="c1">// as in the previous examples</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainDispatch</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainDispatch</span><span class="o">]</span>
   <span class="k">lazy</span> <span class="k">val</span> <span class="n">trainStation</span> <span class="k">=</span> <span class="n">wire</span><span class="o">[</span><span class="kt">TrainStation</span><span class="o">]</span>

   <span class="c1">// dependencies of the module</span>
   <span class="k">def</span> <span class="n">trainShunter</span><span class="k">:</span> <span class="kt">TrainShunter</span> 
   <span class="k">def</span> <span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span>
<span class="o">}</span>
</code></pre></div>
<p>Going further, if the <code>ActorSystem</code> is also a value defined in the modules, we can create an actor factory without the need for an intermediate props value (why a factory? As we may want to do an explicit call to create a single or multiple actors):</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">ReactiveTrainDispatch</span><span class="o">(</span>
   <span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">,</span> 
   <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>

   <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">StationModule</span> <span class="o">{</span>
   <span class="k">def</span> <span class="n">createReactiveTrainDispatch</span> <span class="k">=</span> 
      <span class="n">actorSystem</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="n">wire</span><span class="o">[</span><span class="kt">ReactiveTrainDispatch</span><span class="o">]))</span> 
   <span class="c1">// actor system module dependency</span>

   <span class="k">def</span> <span class="n">actorSystem</span><span class="k">:</span> <span class="kt">ActorSystem</span>

   <span class="c1">// as previously</span>
   <span class="c1">// ...</span>
<span class="o">}</span>
</code></pre></div>
<h2>Injecting other actors</h2>

<p>Apart from services, actors often depend on other actors, holding references to them via <code>ActorRef</code>s. The most common way to obtain references to other actors is by sending them via messages. If, however, you want to &quot;inject&quot; an <code>ActorRef</code> into your actor at the time of creation, you can do it via a constructor as well.</p>

<p>There&#39;s a problem of course with multiple actor references as they all have the same type. With manual DI things are easy - we can just pass the <code>ActorRef</code> we need as the proper constructor argument. If, however, we are using MacWire, or if we want the manual approach to be more typesafe, we can use <a href="#multipleinst">tagging</a>.</p>

<p>Again, here we are modelling actor creation as a factory, as actors are typically created explicitly when needed, unlike the &quot;service&quot; object graph, but we could model them as all other dependencies as well:</p>
<div class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">ReactiveTrainDispatch</span><span class="o">(</span>
   <span class="n">trainLoader</span><span class="k">:</span> <span class="kt">TrainLoader</span><span class="o">,</span> 
   <span class="n">trainDispatch</span><span class="k">:</span> <span class="kt">TrainDispatch</span><span class="o">,</span>
   <span class="n">loadListener</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="kt">@@</span> <span class="kt">LoadListener</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>

   <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">StationModule</span> <span class="o">{</span>
   <span class="k">def</span> <span class="n">createReactiveTrainDispatch</span><span class="o">(</span>
      <span class="n">loadListener</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="kt">@@</span> <span class="kt">LoadListener</span><span class="o">)</span> <span class="k">=</span> 
      <span class="n">actorSystem</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="n">wire</span><span class="o">[</span><span class="kt">ReactiveTrainDispatch</span><span class="o">]))</span> 

   <span class="c1">// actor system module dependency</span>
   <span class="k">def</span> <span class="n">actorSystem</span><span class="k">:</span> <span class="kt">ActorSystem</span>

   <span class="c1">// as previously</span>
   <span class="c1">// ...</span>
<span class="o">}</span>

<span class="c1">// usage; statically checked ActorRef types!</span>
<span class="k">val</span> <span class="n">loadListener</span> <span class="k">=</span> <span class="n">actorSystem</span>
      <span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">LoadListenerActor</span><span class="o">])</span>
      <span class="o">.</span><span class="n">taggedWith</span><span class="o">[</span><span class="kt">LoadListener</span><span class="o">]</span>

<span class="k">val</span> <span class="n">reactiveTrainDispatch</span> <span class="k">=</span> <span class="n">modules</span>
      <span class="o">.</span><span class="n">createReactiveTrainDispatch</span><span class="o">(</span><span class="n">loadListener</span><span class="o">)</span>
</code></pre></div>
<p><a name="comments"></a></p>

<p><h1>Comments</h1>
  <span style="font-size: 75%"><a href="#top">&#8607; Back to top</a></span> 
  <span style="font-size: 75%"><a href="#comments">&#8609; Comments</a></span> </p>

<div id="disqus_thread"></div>

<script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'di-in-scala'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
</script>

<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<p><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></p>

<p class="message">
  Created using <a href="https://github.com/poole/poole">poole</a> and <a href="http://jekyllrb.com/">jekyll</a>. 

  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
</p>

    </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-53088231-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>
</html>
