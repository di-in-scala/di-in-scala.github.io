
Manual DI isn’t of course a silver bullet. Manually writing new instance creation code for each class, using the correct parameters may be tedious.

That is where [MacWire](https://github.com/adamw/macwire) and the `wire` method can help. `wire` is a [Scala Macro](http://scalamacros.org/), which generates the new instance creation code. 

After using MacWire, the code becomes simpler:

````scala
object TrainStation extends App {
   lazy val pointSwitcher = wire[PointSwitcher]
   lazy val trainCarCoupler = wire[TrainCarCoupler]
   lazy val trainShunter = wire[TrainShunter]

   lazy val craneController = wire[CraneController]
   lazy val trainLoader = wire[TrainLoader] 
   lazy val trainDispatch = wire[TrainDispatch]

   lazy val trainStation = wire[TrainStation]

   trainStation.prepareAndDispatchNextTrain() 
} 
````

If a new dependency is added to a service or if the order of parameters changes, the object-graph wiring code doesn’t have to be altered; the macro will take care of that. Only when introducing a new service, it must be added to the list.

The code is generated at *compile time*, so if you compare the byte code generated by both examples, it will be identical. The generated code is type-checked in the usual way, so we keep the type-safety of the manual approach.

Usage of the `wire` macro can be mixed with creating new instances by hand; this may be needed if, as discussed earlier, creating a new instance isn’t that straightforward.

To access `wire`, you can either import the `com.softwaremill.macwire.MacwireMacros` object, or extend the `Macwire` trait. For details on how to integrate MacWire into your project, see the [github page](https://github.com/adamw/macwire).

## How `wire` works

Given a class, the `wire` macro first inspects the primary constructor, to determine the dependencies needed. For each dependency it then looks for a value which is a subtype of the parameter’s type, in the enclosing method/class/object:

* first it tries to find a value declared in the enclosing method; if multiple values are found, a by-name match is attempted
* then it tries to find a unique value declared in the enclosing type
* finally it tries to find a unique value in parent types (traits/classes)

Here value can be either a `val`, `lazy val` or a no-parameter `def`, as long as the return type matches.

A compile-time error occurs if:

* there are multiple values of a given type in the enclosing type, or in parent types
* there is no value of a given type